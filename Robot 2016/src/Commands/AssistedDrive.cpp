// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "AssistedDrive.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AssistedDrive::AssistedDrive(double distanceInFeet, double relativeBearing): Command() {
    m_distanceInFeet = distanceInFeet;
    m_relativeBearing = relativeBearing;
        // Use requires() here to declare subsystem dependencies
    // eg. requires(chassis);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::driveControl.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

	absBearing = 0;
	gyroTolerance = 0;
	totalDriveTimeNeeded = 0;
	drivePower = 0;
	timer = new ClockTimer(0);
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AssistedDrive::Initialize() {
	absBearing = Robot::driveControl->GetGyroAngle() + m_relativeBearing;
	gyroTolerance = Robot::driveControl.get()->getAutoGyroTolerance();
	setTravelTime();
	drivePower = Robot::driveControl->getAutoSpeedValue();
	std::cout << "Assisted Drive Leg - " << m_distanceInFeet << "ft == "
			<< totalDriveTimeNeeded << "sec at power " << drivePower
			<< " bearing " << m_relativeBearing << " rel deg " << absBearing
			<< " abs deg +-" << gyroTolerance << std::endl;
	timer = new ClockTimer(totalDriveTimeNeeded);
}

// Called repeatedly when this Command is scheduled to run
void AssistedDrive::Execute() {
	if (!isAngleInTolerance()) {
		// If bearing off... stop timer and turn bot...

		timer->stop();

		float degreeOffset = degreeOffsetToMatchBearing();

		float direction = 1;
		if (abs(degreeOffset) != degreeOffset) {
			direction = -1;
		}

		float speed = .5;
		if (abs(degreeOffset) > 90) {
			speed = .5;
		} else if (abs(degreeOffset) > 45) {
			speed = .3;
		} else {
			speed = .2;
		}

		std::cout << "[TURN] Offset " << degreeOffset << " Drive(0, "
				<< direction * speed << ")" << std::endl;

		Robot::driveControl->TakeJoystickInputs(0, direction * speed);
	} else {
		// If on bearing, start timer and drive bot...
		timer->start();

		Robot::driveControl->TakeJoystickInputs(drivePower, 0);
	}
}

// Make this return true when this Command no longer needs to run execute()
bool AssistedDrive::IsFinished() {
    return timer->expired();
}

// Called once after isFinished returns true
void AssistedDrive::End() {
	timer->stop();
	Robot::driveControl->TakeJoystickInputs(0, 0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AssistedDrive::Interrupted() {
	End();
}

/**
 * Tests to see if the current gyro angle is within the tolerances specified in the dashboard
 */
bool AssistedDrive::isAngleInTolerance() {
	float currentAngle = Robot::driveControl.get()->GetGyroAngle();
	if (absBearing >= currentAngle - gyroTolerance && absBearing <= currentAngle + gyroTolerance) {
		return true;
	} else {
		return false;
	}
}

/**
 * Should return degrees to turn to match the desired bearing. Positive == clockwise.
 */
float AssistedDrive::degreeOffsetToMatchBearing() {
	float currentAngle = Robot::driveControl.get()->GetGyroAngle();
	return absBearing - currentAngle;
}

void AssistedDrive::setTravelTime() {
	float tenFootTravelTime = Robot::driveControl->getAutoSetPowerTime();
	totalDriveTimeNeeded = (tenFootTravelTime/10) * m_distanceInFeet;
}
