// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.



#include "AutonomousCommand.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(std::string Autoroutine): CommandGroup() {
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
     // Add Commands here:
    // e.g. AddSequential(new Command1());
    //      AddSequential(new Command2());
    // these will run in order.

    // To run multiple commands at the same time,
    // use AddParallel()
    // e.g. AddParallel(new Command1());
    //      AddSequential(new Command2());
    // Command1 and Command2 will run in parallel.

    // A command group will require all of the subsystems that each member
    // would require.
    // e.g. if Command1 requires chassis, and Command2 requires arm,
    // a CommandGroup containing them would require both the chassis and the
    // arm.
              // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
                      // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS

	// Robot Width = 29 1/4" or 2.4375'
	// Distances measured from front center of bot

	/*
	 * Autoroutine Possibilities
	 *
	 * reach
	 * gunit
	 * spyscore
	 * offsetbreechright
	 * offsetbreechleft
	 *
	 */

	std::cout << "Executing Auto " << Autoroutine << std::endl;

	// All comments about distance forward from auto line are off by 2'
	if (Autoroutine == "reach") {
		// Step 1 -> Forward 141.22" == 11.768'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(9.768), 0));

	} else if (Autoroutine == "gunit") {
		// Step 1 -> Forward 150" == 12.5'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(10.5), 0));

	} else if (Autoroutine == "spyscore") {
		// Step 1 -> Turn clockwise 60 degrees & Forward 59" == 4.916'
		AddSequential(new AssistedDrive(4.916, 60));
		// Step 2 -> Turn counter-clockwise 90 degrees & Forward 97.5" == 8.125'
		AddSequential(new AssistedDrive(8.125, -90));

	} else if (Autoroutine == "offsetbreechright") {
		// Step 1 -> Forward 70" == 5.833'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(3.833), 0));
		// Step 2 -> Turn clockwise 90 degrees & Forward 50" == 4.166'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(4.166), 90));
		// Step 3 -> Turn counter-clockwise 90 degrees & Forward 80" == 6.666'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(6.666), -90));

	} else if (Autoroutine == "offsetbreechleft") {
		//Step 1 -> Forward 70" == 5.833'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(3.833), 0));
		//Step 2 -> Turn counter-clockwise 90 degrees & Forward 50" == 4.166'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(4.166), -90));
		//Step 3 -> Turn counter-clockwise 90 degrees & Forward 80" == 6.666'
		AddSequential(new AssistedDrive(DistanceAddingRobotLength(6.666), 90));
	}

 }

double AutonomousCommand::DistanceAddingRobotLength(double distance) {
	// Robot Length 30.5" or 2.5416'

	return distance + 2.5416;
}
