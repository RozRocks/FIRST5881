// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.techvalleyhigh.frc5881.subsystems;

import org.techvalleyhigh.frc5881.Robot;
import org.techvalleyhigh.frc5881.RobotMap;
import org.techvalleyhigh.frc5881.commands.*;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveControl extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	
	private static final String AUTO_GYRO_TOLERANCE = "Auto Gyro Tolerance (+- Deg)";
	private static final String FULL_POWER_TIME = "Full Power 10' Time";
	private static final String FULL_SPEED_VALUE = "FULL";
	private static final String HALF_POWER_TIME = "Half Power 10' Time";
	private static final String HALF_SPEED_VALUE = "HALF";
	private static final String ONETHIRD_POWER_TIME = "One-Third Power 10' Time";
	private static final String ONETHIRD_SPEED_VALUE = "THIRD";
	private static final String JOYSTICK_DEADZONE_X = "Joystick X-Axis Deadzone";
	private static final String JOYSTICK_DEADZONE_Y = "Joystick Y-Axis Deadzone";

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftSpeedController1 = RobotMap.driveControlLeftSpeedController1;
    private final SpeedController leftSpeedController2 = RobotMap.driveControlLeftSpeedController2;
    private final SpeedController rightSpeedController1 = RobotMap.driveControlRightSpeedController1;
    private final SpeedController rightSpeedController2 = RobotMap.driveControlRightSpeedController2;
    private final RobotDrive robotDrive = RobotMap.driveControlRobotDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private ADXRS450_Gyro digitalGyro;
    private SendableChooser autoSpeedChooser;

    public DriveControl() {
    	super();
    	initSmartDashboard();
    }
    
    public DriveControl(String name) {
    	super(name);
    	initSmartDashboard();
    }
    
    private void initSmartDashboard() {
    	calibrateGyro();
    	
    	// Timing settings. These are timed numbers measured as the amount of time it takes
        // the robot to move 10' at the given power level.
        SmartDashboard.putNumber(FULL_POWER_TIME, 1.1);
        SmartDashboard.putNumber(HALF_POWER_TIME, 2.2);
        SmartDashboard.putNumber(ONETHIRD_POWER_TIME, 3.3);
        
        // Gryo tolerance - used in auto to provide non-perfect directions
        SmartDashboard.putNumber(AUTO_GYRO_TOLERANCE, 5);

        autoSpeedChooser = new SendableChooser();
        autoSpeedChooser.addDefault("Full Speed", FULL_SPEED_VALUE);
        autoSpeedChooser.addObject("Half-Speed", HALF_SPEED_VALUE);
        autoSpeedChooser.addObject("1/3rd Speed", ONETHIRD_SPEED_VALUE);
       	SmartDashboard.putData("Autonomous Speed Selection", autoSpeedChooser);
       	
       	SmartDashboard.putNumber(JOYSTICK_DEADZONE_X, 0.1);
       	SmartDashboard.putNumber(JOYSTICK_DEADZONE_Y, 0.1);
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Drive(10));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void calibrateGyro() {
    	digitalGyro = RobotMap.driveControlDigitalGyro;
    	digitalGyro.calibrate();
    }
    
    public double getGyroAngle() {
    	return digitalGyro.getAngle();
    }
    
    public int getAutoGyroTolerance() {
    	return (int) SmartDashboard.getNumber(AUTO_GYRO_TOLERANCE, 5);
    }

   public void updateDashboard() {
    	SmartDashboard.putNumber("Gyro Heading", getGyroAngle());
    }
   
   public void stopDrive() {
	   robotDrive.arcadeDrive(0, 0);
   }
   
   public void rawDrive(float move, float turn) {
	   updateDashboard();
	   robotDrive.arcadeDrive(move, turn, true);
   }

    /*
     * Takes the axis-values from the joystick, applies the deadzone, robot orientation,
     * scales the values, and translates to motion.
     */
    public void takeJoystickInputs(int scale) {
    	Joystick joystick = Robot.oi.getJoystick();
    	double x = joystick.getX();
    	double y = joystick.getY();
    	
    	double deadzone_x = Math.abs(SmartDashboard.getNumber(JOYSTICK_DEADZONE_X, 0.1));
    	double deadzone_y = Math.abs(SmartDashboard.getNumber(JOYSTICK_DEADZONE_Y, 0.1));
    	
    	if (x < deadzone_x && x > (deadzone_x * -1)) {
    		x = 0;
    	}
    	if (y < deadzone_y && y > (deadzone_y * -1)) {
    		y = 0;
    	}
    	
    	if (Robot.chassis.isOrientationInverted()) {
    		x = -1 * x;
    		y = -1 * y;
    	}
    	
    	Position scaled = scaleAxis(x, y, scale);
    	
    	robotDrive.arcadeDrive(-1 * scaled.y, -3 * scaled.x / 4, true);
    }

    public double getFullPowerTime() {
    	return SmartDashboard.getNumber(FULL_POWER_TIME, 0.92);
    }

    public double getHalfPowerTime() {
    	return SmartDashboard.getNumber(HALF_POWER_TIME, 1.84);
    }

    public double getThirdPowerTime() {
    	return SmartDashboard.getNumber(ONETHIRD_POWER_TIME, 2.76);
    }
    
    public String getAutoSpeedSelection() {
    	return (String) autoSpeedChooser.getSelected();
    }
    
    /**
     * Returns the float value for the motor drive power for the given set time.
     */
    public float getAutoSpeedValue() {
    	String speed = getAutoSpeedSelection();
    	if (speed == FULL_SPEED_VALUE) {
    		return 1;
    	} else if (speed == HALF_SPEED_VALUE) {
    		return 0.5f;
    	} else if (speed == ONETHIRD_SPEED_VALUE) {
    		return 0.33333f;
    	} else {
    		System.out.println("Unknown autoSpeedSelection: " + speed);
    		return 1f;
    	}
    }

    public double getAutoSetPowerTime() {
    	String speed = getAutoSpeedSelection();
    	if (speed == FULL_SPEED_VALUE) {
    		return getFullPowerTime();
    	} else if (speed == HALF_SPEED_VALUE) {
    		return getHalfPowerTime();
    	} else if (speed == ONETHIRD_SPEED_VALUE) {
    		return getThirdPowerTime();
    	}

    	return 1d;
    }
    
    /**
     * Scale Axis by a given factor
     */
    private Position scaleAxis(double x, double y, float scaleFactor) {
    	// Scaling the input to exponential curve. x = input from stick -1..1, f=factor
    	// Where as f increases the slower the ramp to full speed across low values of |x|
    	// and the faster the ramp to full for higher values of |x|. f must be 2 or greater and
    	// a whole number. Value needs to be multiplied by -1 if x<0
    	// scaled = ((f^(|x|))-1/(f-1)


    	double xScaled = ((Math.pow(scaleFactor, Math.abs(x)))-1)/(scaleFactor-1) * (x < 0 ? -1 : 1);
    	double yScaled = ((Math.pow(scaleFactor, Math.abs(y)))-1)/(scaleFactor-1) * (y < 0 ? -1 : 1);

    	SmartDashboard.putNumber("Scale Factor", scaleFactor);
    	SmartDashboard.putNumber("Y-Scale", yScaled);
    	SmartDashboard.putNumber("X-Scale", xScaled);

    	return new Position(xScaled, yScaled);
    }
    
    private class Position {
    	public double x;
    	public double y;
    	
    	public Position(double xValue, double yValue) {
    		x = xValue;
    		y = yValue;
    	}
    }
}

